import{_ as n,o as s,c as a,a as e}from"./app-5b0f25a8.js";const t={},o=e(`<h1 id="前端模块化" tabindex="-1"><a class="header-anchor" href="#前端模块化" aria-hidden="true">#</a> 前端模块化</h1><h2 id="首先为什么需要模块化-模块化解决了什么问题" tabindex="-1"><a class="header-anchor" href="#首先为什么需要模块化-模块化解决了什么问题" aria-hidden="true">#</a> 首先为什么需要模块化？模块化解决了什么问题？</h2><p>其实在其他语言中，模块往往是语言标准的一部分。模块最基本的一个作用就是隔离命名空间，避免出现命名冲突。</p><p>所以在js非模块化开发的时候变量命名特别需要注意。所以js的模块化发展是必然的。</p><h2 id="那前端的模块化有哪些规范呢" tabindex="-1"><a class="header-anchor" href="#那前端的模块化有哪些规范呢" aria-hidden="true">#</a> 那前端的模块化有哪些规范呢？</h2><p>前端的模块化一直在发展，历史中形成规范其实挺多的。</p><p>一个是<code>CommonJS</code>规范，也就是cjs，用于写nodejs。</p><p>一个是<code>ESM</code>规范，我们前端的项目现在都是用这个。</p><p>一个是<code>UMD</code>规范，一般我们给别人用npm包的时候要按照这个规范打包，它其实是兼容AMD和CommonJS。</p><p>还要一个是<code>iife</code>，一般是前端应用打包时候用的，打出来的js立即执行。</p><h2 id="commonjs和es-module的区别" tabindex="-1"><a class="header-anchor" href="#commonjs和es-module的区别" aria-hidden="true">#</a> CommonJS和ES Module的区别</h2><h3 id="模块的静态加载-依赖提前加载-和动态加载-依赖适时加载" tabindex="-1"><a class="header-anchor" href="#模块的静态加载-依赖提前加载-和动态加载-依赖适时加载" aria-hidden="true">#</a> 模块的静态加载(依赖提前加载)和动态加载(依赖适时加载)</h3><p>ESM的模块写法是在文件的头部把依赖全部import进来，显然ESM属于静态加载，也就是依赖提前加载好。</p><p>CommonJS我们可以在代码任何位置使用requie加载依赖，显然属于动态加载，也就是依赖适时加载。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a.mjs</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;execute a.mjs&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">import</span> b <span class="token keyword">from</span> <span class="token string">&quot;./b.mjs&quot;</span>
<span class="token comment">// b.mjs</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;execute b.mjs&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token string">&quot;B&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出<br> execute b.mjs<br> execute a.mjs<br> 由于a依赖b，所以b会提前加载执行，然后才执行a的代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;execute a.js&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./b.js&quot;</span><span class="token punctuation">)</span>
<span class="token comment">// b.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;execute b.js&quot;</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token string">&quot;B&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出<br> execute a.js<br> execute b.js<br> commonjs属于适时加载，先执行a，然后碰到require(b)，再加载b执行</p><h3 id="循环依赖问题" tabindex="-1"><a class="header-anchor" href="#循环依赖问题" aria-hidden="true">#</a> 循环依赖问题</h3><p>无论什么模块化规范，都逃不过循环依赖的问题。因为依赖加载的原理不同，所以ESM和CommonJS在循环依赖的表现上也会有所不同。</p><p>我们先来看看CommonJS的代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a.js</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./b.js&quot;</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;in a.js function&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// b.js</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;./a.js&quot;</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;in b.js function&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>// 运行 node a.js 会报错，a() is not a function<br> 首先加载a.js，遇到require(b),这时候去加载b.js， b里遇到require(a),这时候去加载a, 但是由于a里面exports还没执行，所以a是找不到的，所以就会报错a不是一个函数。 但是相同的代码在ESM里却可以执行，因为ESM是依赖提前加载。</p></blockquote><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// a.mjs</span>
<span class="token keyword">import</span> b <span class="token keyword">from</span> <span class="token string">&quot;./b.mjs&quot;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;in a.mjs function&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// b.mjs</span>
<span class="token keyword">import</span> a <span class="token keyword">from</span> <span class="token string">&quot;./A.mjs&quot;</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;in b.mjs function&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>运行 node a.mjs，输出<br> in a.mjs function<br> in b.mjs function</p></blockquote><blockquote><p>首先扫描a.mjs文件中import/export语句，确定a.mjs导出一个函数，并且import语句依赖于b.mjs 然后再扫描b.mjs，确定b.mjs导出一个函数，并且import语句依赖a.mjs，由于a.mjs已经处理过了，所以可以直接加载，整个依赖关系就加载好了。</p></blockquote><h3 id="es-module可以做treeshaking" tabindex="-1"><a class="header-anchor" href="#es-module可以做treeshaking" aria-hidden="true">#</a> ES Module可以做treeShaking</h3><p>esm模块规范可以做treeShaking，commonjs则不行</p>`,28),p=[o];function c(i,u){return s(),a("div",null,p)}const r=n(t,[["render",c],["__file","js-module.html.vue"]]);export{r as default};
