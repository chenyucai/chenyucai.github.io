import{_ as a,o as e,c as s,a as n}from"./app-5b0f25a8.js";const i="/images/js-micro-1.png",r={},t=n('<h1 id="浅谈微前端" tabindex="-1"><a class="header-anchor" href="#浅谈微前端" aria-hidden="true">#</a> 浅谈微前端</h1><h2 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景" aria-hidden="true">#</a> 使用场景</h2><p>一般来说有两种场景可能会考虑微前端。</p><ol><li>一个大型系统被拆分成一个个的组件或小系统，然后每个组件都由一个小的团队开发。这时候这个大的系统就需要被集成，微前端是一种很好的集成机制。每个组件各自维护，互不干扰，还可以动态插拔。</li><li>老项目技术栈落后，但是一直有新的需求，比如在旧的页面里面嵌入一个表格，你想使用当下流行的技术，减少开发成本。那么微前端也是一种不错的选择。</li></ol><h2 id="基本原理" tabindex="-1"><a class="header-anchor" href="#基本原理" aria-hidden="true">#</a> 基本原理</h2><p>基于上面的使用场景我们可以大概想象得到一个微前端应用是长下面这样的(以qiankun为例)</p><p><img src="'+i+`" alt="1"></p><h3 id="_1-如何挂载子应用" tabindex="-1"><a class="header-anchor" href="#_1-如何挂载子应用" aria-hidden="true">#</a> 1.如何挂载子应用？</h3><p>先注册子应用，qiankun会根据配置信息entry知道要加载哪些资源</p><h3 id="_2-js如何隔离" tabindex="-1"><a class="header-anchor" href="#_2-js如何隔离" aria-hidden="true">#</a> 2.JS如何隔离</h3><p>子应用的入口js一般推荐用webpack umd打包，使用umd是因为要导出一些生命周期函数给qiankun调用。</p><p>qiankun拿到入口js后不是立即执行的，这里它要做js隔离，其实主要就是做window对象的隔离。</p><p>原理是拿到js代码后，给代码包裹一层立即执行函数，然后把window挂到一个proxy对象上，然后再eval执行js代码。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">const</span> script <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">
    ;(function (window) {
        // 入口js代码
    })(proxy)
</span><span class="token template-punctuation string">\`</span></span>
<span class="token function">eval</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-css如何隔离" tabindex="-1"><a class="header-anchor" href="#_3-css如何隔离" aria-hidden="true">#</a> 3.CSS如何隔离</h3><p>这一点qiankun好像并不能做到很好的隔离。除非用到<code>shadow dom</code>，但是用这个有一定成本，所以也没有用到。</p><p>我们日常开发中其实是可以通过约定规范做到css隔离的，我们的样式代码都用scope作用域，然后在打包css的时候可以在css-loader里加个前缀，这样子就能起到隔离作用了。</p><h3 id="_4-应用之间如何通信" tabindex="-1"><a class="header-anchor" href="#_4-应用之间如何通信" aria-hidden="true">#</a> 4.应用之间如何通信</h3><p>我们还要考虑应用之间的通信问题。qiankun提供了globalState的方法很方便的实现了能在应用之间进行通信。</p><p>解决上面4个问题，我们就能实现一个简单的微前端框架了。</p><h2 id="为什么不用iframe" tabindex="-1"><a class="header-anchor" href="#为什么不用iframe" aria-hidden="true">#</a> 为什么不用iframe?</h2><ul><li>子应用弹窗的蒙层只能覆盖iframe区域。</li><li>由于是通过iframe.src的方式，刷新页面后子应用只能重新加载首页。</li><li>应用之间通信麻烦，只能通过postMessage方式。</li></ul>`,22),d=[t];function c(l,o){return e(),s("div",null,d)}const h=a(r,[["render",c],["__file","js-micro.html.vue"]]);export{h as default};
