import{_ as e,o as a,c as d,a as o}from"./app-5b0f25a8.js";const t={},i=o('<h1 id="vite为什么快" tabindex="-1"><a class="header-anchor" href="#vite为什么快" aria-hidden="true">#</a> vite为什么快</h1><h2 id="底层使用go语言-编译速度快" tabindex="-1"><a class="header-anchor" href="#底层使用go语言-编译速度快" aria-hidden="true">#</a> 底层使用go语言，编译速度快</h2><p>底层使用的<code>esbuild</code> 是由go编写，cpu密集下更具性能优势，编译速度更快，相比较其他打包工具的速度提升10~100倍的差距。</p><h2 id="unbundle思想" tabindex="-1"><a class="header-anchor" href="#unbundle思想" aria-hidden="true">#</a> unbundle思想</h2><ul><li>不用打包，一个 <code>import</code> 语句即代表了一个 <code>HTTP</code> 请求。</li><li>但要使用预构建将依赖中各种其他模块化规范(CommonJS、UMD)转换成ESM，以提供给浏览器进行加载。</li><li>预构建还会将第三方依赖模块的<code>import</code>合并，以减少 <code>import</code>模块请求次数。</li></ul><h2 id="充分利用http缓存" tabindex="-1"><a class="header-anchor" href="#充分利用http缓存" aria-hidden="true">#</a> 充分利用http缓存</h2><ul><li>源码模块的请求会根据 <code>304 Not Modified</code> 进行协商缓存，</li><li>而依赖模块请求则会通过 <code>Cache-Control: max-age=31536000,immutable</code> 进行强缓存，因此一旦被缓存它们将不需要再次请求。</li></ul>',7),c=[i];function r(h,l){return a(),d("div",null,c)}const s=e(t,[["render",r],["__file","vite-fast.html.vue"]]);export{s as default};
