import{_ as e,o as a,c as i,a as r}from"./app-5b0f25a8.js";const l={},t=r('<h1 id="_100亿数据排序问题" tabindex="-1"><a class="header-anchor" href="#_100亿数据排序问题" aria-hidden="true">#</a> 100亿数据排序问题</h1><blockquote><p>100亿排序问题：内存不足，一次只允许你装载和操作1亿条数据，如何对100亿条数据进行排序。假设结果要求升序 可以理解为如何给100亿个数字排序</p></blockquote><h2 id="基本思路" tabindex="-1"><a class="header-anchor" href="#基本思路" aria-hidden="true">#</a> 基本思路</h2><h3 id="第一步-数据拆分成若干个小文件" tabindex="-1"><a class="header-anchor" href="#第一步-数据拆分成若干个小文件" aria-hidden="true">#</a> 第一步：数据拆分成若干个小文件</h3><p>假设100亿个数据存在一个大文件中，一次只能操作1亿条数据，显然要拆分来排序，那就分出100个文件，每个文件1亿条数据。</p><p>那数据怎么拆分呢？不可能把所有数据读取出来再拆分，因为内存不够。</p><p>可以使用fs.createReadStream来每次读取部分文件流（注意fs.readFile是一次把文件放到内存中再操作）</p><p>这样每次从大文件中读取一部分数据放入小文件，直到平均拆分成100个小文件。</p><h3 id="第二步-对100个小文件里的数据先进行排序" tabindex="-1"><a class="header-anchor" href="#第二步-对100个小文件里的数据先进行排序" aria-hidden="true">#</a> 第二步：对100个小文件里的数据先进行排序</h3><p>队100个小文件进行排序，可以用快速排序、归并排序、堆排序等等。</p><p>第三步：难点是如何将100个小文件进行合并并排序</p><ol><li>先创建一个文件，用来存放最终结果</li><li>100个小文件已经排好序了，假设是升序。遍历100个文件，每个文件取出第一个数字也就是最小值，组成（数字，文件名）的组合加入到一个数组中。这样最后得到一个有100项，每项是数字+文件名的数组，然后对数组排序，得到一个升序的数组。</li><li>然后重点来了，这里要注意理解。每次取出数组的第一个数字也就是最小值放入结果文件，然后再从这个数字对应的文件取出一个最小值放入数组中，然后再对数组进行排序，再把数组的最小值取出来放入结果文件，再到对应的文件取最小值放入数组进行排序，以此类推，直到100个文件里数字取完，以及数组取完，此时最终结果文件里的全部数字都是有序的了。</li><li>注意理解为什么要到数组最小值对应的文件再取数字？因为数组的最小值被取出后，其他文件的最小值都还在数组里，这个数组永远都是一个最小值集合的数组。</li></ol><h2 id="思维拓展" tabindex="-1"><a class="header-anchor" href="#思维拓展" aria-hidden="true">#</a> 思维拓展</h2><ul><li>类似的100亿个数字求和，求中位数，求平均数，套路就是一样的了。</li><li>求和：统计每个小文件的和，返回给master再求和就可以了。</li><li>求平均数：上面能求和了，再除以100亿就是平均数了</li><li>求中位数：在排序的基础上，遍历到中间的那个数就是中位数了。</li></ul>',14),h=[t];function d(s,c){return a(),i("div",null,h)}const n=e(l,[["render",d],["__file","js-100sort.html.vue"]]);export{n as default};
